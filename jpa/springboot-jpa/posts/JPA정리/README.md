# 영속성 관리

엔티티의 생명주기는 아래와 같은 단계로 구성된다.

- 비영속(new/transient)
    - 영속성 컨텍스트에 아직 관여되지 않는 새로운 상태
- 영속(Managed)
    - 영속성 컨텍스트에 추가되어 관리되는 상태
- 준영속(Detached)
    - 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(Removed)
    - 영속성 컨텍스트에서 삭제된 상태

영속성 컨텍스트를 사용하게 되면 다음과 같은 이점이 있다.
1. 1차 캐시
- 1차 캐시에 데이터를 저장하면서 캐시에 존재하는 데이터에 대한 조회 요청을 경우 데이터베이스에서 조회하지 않고 캐시에서 데이터를 조회하면서 성능을 향상시킨다
2. 동일성 보장
    - 1차 캐시를 사용함에 따라 REPEATABLE READ 등급의 트랜잭션 격리수준을 데이터베이스 수준에서가 아닌 애플리케이션 수준에서도 지원해주게 된다.
3. 트랜잭션을 지원하는 쓰기 지연
    - 트랜잭션이 시작되고 트랜잭션을 커밋하기 전의 변경사항에 대하여 바로 데이터베이스에 쿼리를 날리지 않고 누적하였다가, 트랜잭션이 커밋되는 순간 한번에 데이터베이스의 질의한다.
4. 변경 감지(Dirty Checking)
    - 1차 캐시에 저장한 스냅샷과 엔티티를 비교하여 데이터의 변경사항이 발생하였을 경우 변경에 대한 부분을 감지하여 쓰기 지연 SQL 저장소에서 업데이트 SQL을 생성하여 트랜잭션이 커밋되는 순간 별도의 업데이트 쿼리를 날리지 않아도 변경사항이 데이터베이스에 적용된다.
5. 지연 로딩(Lazy Loading)

영속성 컨텍스트의 변경사항을 데이터베이스에 실제도 반영하는 것을 플러시(Flush)라고 하며, 아래와 같은 절차에 의하여 발생하게 된다.
1. 변경 감지
2. 변경된 엔티티 사항에 대하여 쓰기 지연 SQL 저장소에 변경 사항에 대한 SQL이 등록된다.
3. 등록된 쓰기 지연 SQL 저장소의 변경 SQL을 데이터베이스에 질의한다.

이와 같은 Flush를 발생시키는 방법은 아래의 경우에 발생하게 된다.
1. em.flush를 통한 직접 호출
2. 트랜잭션을 커밋하는 경우
3. JPQL 쿼리를 실행하는 경우

단 플러시는 변경 내용을 데이터베이스에 동기화 시키고, 영속성 컨텍스트를 비우는 행위를 하지는 않는다. 이는 준영속 상태로 만들어야 하는데 이를 위해서는 아래와 같은 방법이 있다.
1. em.detach(entity)
2. em.clear()
3. em.close()

# 엔티티 매핑
엔티티를 매핑하는 애노테이션은 크게 객체와 테이블을 매핑(@Entity ,@Table), 필드와 컬럼을 매핑(@Column), 기본키를 매핑(@Id), 연관관계를 매핑(@ManyToOne, @JoinColumn) 하는 애노테이션 등으로 구성되어 있다.

## @Entity
- JPA가 관리하는 엔티티가 되는 애노테이션
- 기본 생성자는 필수로 생성하여야 한다(파라미터가 없는 public, protected 레벨의 생성자)
- final 클래스, enum, 인터페이스, inner클래스는 엔티티로 사용될 수 없다
- 저장할 필드에 final을 사용할 수 없다

Hibernate에서는 엔티티를 정의하고 서버를 가동시키면 데이터베이스 스키마를 자동 생성하는 옵션을 제공해주고 있고, 아래와 같은 다양한 설정을 지원해주고 있다.
```jJava
hibernate.hbm2ddl.auto
```
- create: 기존 테이블을 삭제한 후 다시 생성(Drop & Create)
- create-drop: Create와 동일하게 동작하나 서버를 종료하는 시점에 테이블을 Drop
- update: 스키마에 대한 변경분만 적용
- validate: 엔티티와 테이블이 정상적으로 매핑되어 있는지 검증
- none: 해당 설정을 사용하지 않음

## 기본키 매핑
기본키를 매핑하는 애노테이션은 @Id, @GeneratedValue가 제공되고 있고, 기본키를 매핑하는 방법은 아래와 같이 구성되어 있다.
- 직접 할당: @Id 애노테이션만 사용하는 경우
- 자동 생성: @GeneratedValue를 함께 사용하는 경우
    - IDENTITY: 데이터베이스에 위임하는 경우(ex: Mysql)
    - SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용(ex: Oracle), @SequenceGenerator 애노테이션이 필요
    - Table: 키 생성용 테이블을 사용, 모든 DB에서 사용, @TableGenerator 애노테이션이 필요
    - AUTO: 방언에 따라 자동 설정되고, 기본값

# 연관관계 매핑
연관관계의 주인에 대한 양방향 매핑 규칙은 아래와 같다
- 객체의 두 관계중 하나를 연관관계의 주인으로 지정한다
- 연관관계의 주인만이 외래 키를 관리하게 된다(등록, 수정)
- 주인이 아닌 쪽은 읽기만 가능하고, 쓰기 작업은 불가능하다
- 주인은 mappedBy 속성을 사용할 수 없다
- 주인이 아니면 mappedBy 속성으로 주인을 지정하게 된다

그럼 주인은 어떻게 정해야 될지 고민하게 되는데, 우선 주인은 외래 키가 있는 곳을 주인으로 정하면 된다.
그리고 양방향 연관관계를 정의할 경우에는 항상 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정해야 한다. 이를 위하여 연관관계 편의 메서드를 생성하는 것이 좋다. 또한 양방향 연관관계 매핑시에 무한루프에 빠지지 않도록 조심해야 한다.

## 다양한 연관관계 매핑
### 다대일(N:1)
주로 가장 많이 사용하는 연관관계는 다대일 단방향이며 외래 키가 있는 쪽이 연관관계의 주인인 다대일 양방향 관계도 사용한다.

### 일대다(1:N) 단향향
- 일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인이다
- 테이블 일대다 관계는 항상 다(N)쪽에 외래키가 있다
- 객체와 테이블의 차이 때문에 반대편 테이블의 외래키를 관리하는 특이한 구조이다
- @JoinColumn을 꼭 사용해야 한다. 그렇지 않으면 조인 테이블 방식을 사용하게 되고, 이렇게 되면 중간에 테이블이 하나 추가되게 된다.
- 엔티티가 관리하는 외래 키가 다른 테이블에 있게 되고, 연관관계 관리를 위하여 UPDATE SQL이 추가로 실행되야 한다
- 따라서 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하는 것이 더 효율적이다

### 일대일(1:1) 매핑
1. 주 테이블에 외래 키
- 주 객체가 대상 객체의 참조를 가지를 것처럼 주 테이블이 외래키를 가지고 해당 키를 통해 테이블을 찾음
- 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
- 값이 없으면 외래 키에 Null을 허용하게 됨
2. 대상 테이블에 외래 키
- 대상 테이블에 외래 키가 존재하는 경우
- 주 테이블과 대상 테이블을 일대일에서 일대 관계로 변경할 때 테이블 구조 유지
- 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨

## 주요 매핑 애노테이션 정리
### @JoinColumn
- 외래키를 매핑할때 사용된다
- 주요 속성
  - name: 매핑할 외래키 이름
  - referencedColumnName: 외래키가 참조하는 대상 테이블의 컬럼명
  - foreignKey(DDL): 외래키 제약조건을 직접 지정할 수 있지만, 해당 속성은 테이블을 생성할 때만 사용 가능하다
### @ManyToOne
- optional: false일 경우 항상 연관된 엔티티가 있어야 한다
- fetch: 글로벌 페치 전략을 설정한다
  - @ManyToOne 기본값: EAGER
  - @OneToMany 기본값: LAZY
- cascade: 영속성 전이 기능을 사용한다

### @OneToMany
- mappedBy: 연관관계의 주인 필드를 선택한다
- fetch: 글로벌 페치 전략을 설정한다
  - @ManyToOne 기본값: EAGER
  - @OneToMany 기본값: LAZY
- cascade: 영속성 전이 기능을 사용한다

## 상속관계 관련 주요 애노테이션
- @Inheritance(strategy=InheritanceType.{})
  - JOINED: 조인 전략
  - SINGLE_TABLE: 단일 테이블 전략
  - TABLE_PER_CLASS: 구현 클래스마다 테이블 전략
- @DiscriminatorColumn(name=“DTYPE”)
- @DiscriminatorValue(“XXX”)
- @MappedSuperclass
  - 엔티티가 공통적으로 사용하는 정보들을 모으는 역할, 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통적으로 적용해야 되는 정보들을 설정할 때 주로 사용한다

## 프록시와 즉시 로딩에서 주의해야 할 점
가급적이면 지연 로딩 방식을 사용하는게 좋다. 즉시 로딩을 사용하면 예상치 못한 SQL이 발생할 수 있으며, N+1 문제가 발생될 수 있다.
또한 @ManyToOne, @OneToOne은 기본이 즉시 로딩이므로 LAZY로 변경해 주는것이 좋다.
반면에 @OneToMany, @ManyToMany는 기본이 지연 로딩이다

## 영속성 전이(CASCADE)
특정 엔티티를 영속 상태로 만들때 연관된 엔티티도 함께 영속상태로 만들고 싶을 사용 한다. 예를 들면 부모 엔티티를 저장할 때, 자식 엔티티도 함께 저장한다.

## 고아 객체
부모 엔티티와 연관관계가 끊어진 자식객체를 의미하며, 이를 자동으로 삭제해 줄 지 여부에 대한 옵션값을 제공한다(orphanRemoval 값을 true로 설정)

## 임베디드 값 타입을 사용하는 방법
- @Embeddable: 값 타입을 정의하는 곳에 표시
- @Embedded: 값 타입을 사용하는 곳에 표시
- 이때 기본 생성자는 필수이다
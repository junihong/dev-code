# OOP
## 절차지향 프로그래밍
- 구현 대상을 문제 해결을 위한 흐름(알고리즘, 로직)에 따라 코드를 구성하고 구현하는 방식
- 대표 프로그래밍 언어 : C언어
- 함수, 조건문, 반복문 구조로 대부분의 구현 문제 해결이 가능

## 객체 지향 프로그래밍(Objec Orient Programming)
- 현실 세계의 객체 모델을 바탕으로 프로그램을 구조화하고 개발하는 프로그래밍 기법
- 절차 지향에 비하여 사람의 사고방식에 더 가까움
- 객체들의 관계를 통해서 프로세스가 진행
- 어플리케이션을 구성하는 요소들을 객체로 바라보고, 객체들을 유기적으로 연결하여 프로그래밍
- 단순히 실세계를 모방하기보다 객체간의 요청과 응답, 역할과 책임, 협력의 자율적인 관계에 집중
> 객체지향 프로그램밍은 실 세계에 존재하고 인지하고 있는 객체를 소프트웨어의 세계에서 표현하기 위해 객체의 핵심적인 개념 또는 기능만을 추출하는 추상화를 통해 모델링하려는 프로그래밍 패러다임. 다시 말해 우리가 주변의 실 세계에서 사물을 인지하는 방식을 프로그래밍에 접속하려는 사상

### 객체지향 프로그래밍의 장점
- 캡슐화, 상속, 다형성 등의 객체 지향 특성을 언어 레벨에서 지원
- 변경 발생 시 코드 수정이 아닌 추가/확장을 통한 해결 가능
- 유지 보수 용이 및 변화에 따른 문제 최소화
- 코드 및 구조 재사용성 증가
- 협업이 용이

### 객체와 클래스
- 객체
    - 실세계에서 어떤 구체적인 의미를 구성하는 특정 사물
    - 객체의 상태를 저장하는 데이터와 객체가 수행할 수 있는 기능인 함수를 가지는 소프트웨어 모듈
    - 구체적인 상태를 가짐
    - 객체가 가지고 있는 속성과 할 수 있는 일로 표현
- 클래스
    - 비슷한 속성을 가지는 객체들을 정의할 수 있는 틀
    - 그랜저, 제네시스는 객체, 승용차는 클래스
    - 클래스를 통해 속성이 다른 객체를 만들 수 있음
    - 클래스를 통해 만들어진 객체를 인스턴스라고 함

### 객체지향의 특징
- 캡슐화
    - 객체의 상태와 행위의 캡슐화, 내부적인 비밀의 캡슐화
    - 데이터와 연산을 함계 묶어 데이터를 보호하는 방법 -> 속성, 메서드를 하나의 클래스로 구
    - 객체 내부 구조를 외부에 숨기는 것
    - 꼭 필요한 인터페이스만 외부에 노출
    - Access Modifier를 이용해 멤버 접근 제한, 메서드를 통한 API 제공
- 상속
    - 클래스의 상-하 계층 관게(is-a 관계)
    - 상속을 통해 속성과 기능을 물려줄 수 있음
    - 새로운 속성의 추가나 기능의 수정이 가능
    - 추상화 관계: 자식 클래스로 갈수록 구체적
- 상속(Inheritance)과 합성(Composition)
    - 상속이라는 개념은 객체지향의 장점 중 하나인가
    - 자바의 창시자 제임스 고슬링도 상속의 문제점을 언급함 -> 무분별하거나 잘못 사용되는 문제
    - 상속(is-a 관계)보다는 합성(has-a) 을 권장
    - 올바른 상속은 is-a 관계가 성립하는 경우에만 사용
- 다형성
    - 동일한 요청을 다양한 형태로 반응하는 성질
    - 기본적으로 추상화 개념과 함께 사용
    - 상속과 메서드 오버라이딩을 통해 구현
### 객체 모델링
#### 개념
- 객체를 구조화 하는 작업
- 현재 시스템 또는 앞으로 개발할 시스템의 원하는 모습을 가시화
- 어떤 클래스들이 필요한지에 대해 고민하고 결정하는 활동
- 객체의 필요한 정보들만 추상화
- 모델링 활동의 결과가 UML 다이어그램으로 시각화
- 요구사항 모델, 분석 모델, 설계 모델
- 동적 모델: 객체의 라이프 사이클 동안 변화하는 상태를 모델링
- 정적 모델: 객체가 가질 수 있는 모든 상태와 행동을 시간 독립적으로 모델링
#### 추상화(Abstraction)
- 현실 세계의 모든것을 표헌하는데 한계가 있음(지나치게 복잡함)
- 추상화는 객체의 특정 측면을 추출해서 표현하는 것
- 객체를 클래스로 정의하는 것도 추상화이며 Class Hierarchy도 추상화의 결과물
- 실세계 <- (추상화) -> 모델링 <- (실체화) -> 구현
#### 추상화 기법
- 분류와 인스턴스화
    - 객체들을 공통의 클래스로 분류(자동차, 사람, 스마트폰)
- 일반화와 특수화
    - 같은 분류에 해당하는 클래스들의 계층화
- 집합과 분해
    - 하나의 클래스가 여러 구성요소(클래스)의 집합(부분과 전체) 구조를 만드는 것

# UML
## UML 개요
### UML의 정의
- 1990년대 초 Booch, OMT, OOSE등 다양한 객체지향 모델링 방법의 출현
- 1997 UML 1.1 발표 및 OMG 표준으로 CORBA(Common Object Request Broker Architecture)의 표준 분석 설계 방법으로 채택
- 2022년 기준 가장 최신 버전은 2017년 발표된 2.5.1
### UML 특징
- 시스템의 상호 작용, 전체 구조, 컴포넌트간의 관계 등을 시각적으로 표현
- 여러 표기법과 다이어그램 구조를 정의
- 모델링 결과를 시각적으로 볼 수 있음
    - 시스템 분석 및 설계의 결과물로 활용할 수 있음을 의미
- CASE(Computer-Aided Software Engineering) 도구를 이용하면 자동으로 프로그램 언어의 소스코드 생성까지도 가능
- 서로 다른 역할을 지원하기 위한 여러 뷰를 제공
- UML은 모델링 언어이며 그 자체로 프로세스나 방법론은 아님
### UML Diagram Type
- Structur Diagrams
    - Deployment Diagram, Package Diagram, Class Diagram, COmponent Diagram
- Begavioral Diagrams
    - State Machine Diagram, UseCase Diagram, Activity Diagram, Sequence Diagram
### UML과 방법론
- UML 자체가 방법론은 아니지만 객체지향 분석 설계 프로세스로 유명한 UP(Unified Process)의 기본도구로 포함
Unified Process는 반복적(Iterative) 점진적(Incremental) 소프트웨어 개발 프로세스 프레임워크이다. 가장 잘 알려지고 많이 문서화된 통합 프로세스는 RUP(Rational Unified Process, 상용 도구와 템플릿을 포함하며 IBM에 통합됨)이며 이외 OpenUP와 Agile UP가 대표적이다.

### UML 적용 방법
- UML as sketch
    - 개념적 모델링 결과를 가시적으로 표현
    - 의사소통(Commnunication)에 초점을 둠
    - 비공식적인 형태 혹은 불완전한 다이어그램이 사용되기도 함
- UML as bluePrint
    - 분석/설계 단계의 각 과정에서 필요한 모델을 정의
    - 완전성(Completeness)에 초점을 둠
    - 규격을 정의하는 도구로 사용
- UML as Programming Language
    - 구현 관점 -> UML 다이어그램이 실행 가능한 코드로 컴파일
    - 정교한 도구
    - 프로그램 코드로부터 UML 모델로의 역공학 Reverse Engineering도 가능

### UML Fever
- UML을 사용하면서 발생하는 여러가지 부정적인 현상
- UML은 Silver Buillet이 아니다

### View는 Software Architecture를 다양한 측면에서 바라보는 것
- Three View: Module, Component and Connector, Allocation View(CMU SEI)
    - View, Viewtype, Structure 등으로도 표현
- 4+1 View : Rational Unified Process
- Siemens 4 View : Conceptual, Module, Code, Execution View

### 4+1 View
- 복잡한 시스템의 구조를 하나의 모델로 이해하기 불가능
- 여러 관점에서 구조를 표현하고 이해할 필요
- View는 시스템을 바라보는 관점에서 시스템을 구성하는 요소와 그 요소들 간의 관계를 표현한 것
    - Use Case View: 최종사용자, 분석가, 설계자, 테스트 담당자 관점, 다른 뷰에 대한 검증(Use Case, Use Case Specification, Activity Diagram)
    - Logical(Design) View: 분석 설계자 관점(Class, Object, Package, Composite Structure, State Machine Diagram)
    - Process View: 시스템 통합가 관점(Sequence, Communication, Activity Diagram, Timing Diagram)
    - Implementation(Development) View : 프로그래머 관점(Component, Class Diagram)
    - Deployment View : 시스템 엔지니어 관점(Deployment Digram)

### UML 다이어그램 작성 조언
1. 다이어그램에 너무 많은 것을 포함하려 하지 마라(조건, 순서, 명확한 관계, 파라미터, 리턴)
2. 다이어그램 목적에 맞는 내용만 기술
3. 도메인에 대한 이해 없이 다이어그램부터 그리지 마라
4. 다이어그램을 두려워 하지 마라 -> 절대적인 O,X는 없다
5. 너무 예쁘게 그리려 하지 마라 -> 도구의 한계, 내용이 중요
6. UML은 의사소통이 목적이지 그 자체가 목적이 안디ㅏ
7. UML as sketch
8. KISS(Keep It Simple Stupid)

## 유스케이스 다이어그램
- 시스템의 기능적 요구사항을 획득하기 위한 도구
- 유스케이스 다이어그램은 사용자와 시스템 간의 상호작용을 표현
- 시스템은 사용자를 위해 무엇을 해야 하는가
- 사용자와 상호작용하기 위해 시스템이 제공해야 할 인터페이스는 무엇인가
- 다이어그램에 표현된 내용이 아닌 그 안에 숨어 있는 스토리가 중요
- 단순한 구현 기능 리스트를 만드는 것이 아님
- Use Case Description이 필요
- 아키텍처 설계시에는 유스케이스 실현 과정에 품질속성이 필요한 유스케이스 도출에 집중
### 유스케이스
- 시스템이 제공하는 기능
- 공통적인 사용자 목표에 의해 추상화된 시나리오의 집합
- 세세한 기능 혹은 UI 이벤트(메뉴)가 아님
### 액터
- 유즈케이스를 사용하는 사용자 : 시스템에서 수행하는 역할(Role)
- 연동이 필요한 다른 시스템 혹은 프록시 등도 액터로 정의할 수 있음
### 시나리오
- 사용자와 시스템 간의 상호작용을 기술하는 일련의 절차
- 시퀀스 중 하나가 될 수 있음
### Include
- 독립된 유스케이스의 포함 관계 -> 필수적인 의미를 포함하는 것이며 단순한 사전 조건 의미는 아님
- 예) 휴학 신청 ---> 도서 반납 확인
### Extend
- 기존 UC와 유사하지만 동일하게 처리 안되는 경우 -> 단순 선택 사항 메뉴의 상하 관계가 아님
    - 선택적인 동작을 포함하는 부분 유스케이스
    - 특정 조건에만 실행되는 서브플로우
    - 베이스 유스케이스에 끼워 넣을 수 있는 시나리오셋
- 예)
    - 휴학 신청 <--- 군휴학 신청(O), 수강 신청 <--- 강의 계획서 조회(O)
    - 주문 결제 <--- 카드 결제, 페이 결제(프로세스가 다르다면 X)
    - 관리 <--- 사용자 관리, 데이터 관리, 로그 관리(X)
### UseCase Description
- 유스케이스 명세라고 하며 시스템의 기능적 요구사항들을 이야기 형식으로 서술
- 유스케이스를 도출하는 것은 문제 도메인에 대해 보다 갚이 이해하고 사용자가 필요로 하는 요구사항을 명확하게 하는 것
- 구조적이지 않은 방법으로 확보된 사용자 요구사항을 재 정리하는 과정이며
- 이 과정에서 액터 도출, 유스케이스 다이어그램, 유스케이스 명세서 등이 작성됨
- 유스케이스명: 액터가 시스템을 통해 달성할 목적을 명확하게 문장으로 표현
- 액터명: 시스템에서 수행하는 역할 혹은 사용자
- 개요: 유스케이스를 수행하는 개요
- 사전 조건: 유스케이스의 기본흐름이 올바르게 동작되기 위해 사전에 충족되어야 하는 조건
- 사후 조건: 유스케이스가 실행된 후 만족해야 하는 조건(액터에게 제공되는 결과, 시스템의 상태)
- 정상 프름(Normal Flow): 시스템과 액터 사이에 목적 달성을 위한 기본적인 상호작용 흐름
    - 정상 흐롬: 어떤 오류나 예외가 발생하지 않고 모든 것이 완전히 수행되는 것을 전제
    - 정상 흐름의 첫 번째 단계를 해당 유스케이스를 시작하는 사건으로 기술하며 이를 트리거라고 함
- 대안 흐름(Alternative Flow): 정상 흐름으로부터 경우에 다라 선택적으로 실행되고 다시 정상 흐름으로 돌아오는 흐름이나 오류
    - 예외가 발생한 경우 이를 처리하는 흐름을 기술. 일반적으로 오류, 예외 상황을 의미
    - 예외를 별도로 구분해서 표기 하기도 함

### Use Case 작성 지침
- 점진적 반복을 통해 완성, UP에서는 Inception phase에서 대략 10% 정도가 권장됨
- 단순한 문법 구조 사용: 주어 - 목적어 - (부사) - 동사
    - 예) 교수는 학생 평가를 위해 시험을 본다
- 해당 시나리오를 수행하는 주체를 명확해게 함
- 액터의 행동/움직임이 아닌 의도를 서술하라
    - 나쁜 예) 1. 시스템이 이메일을 묻는다. 2. 사용자가 이메일을 입력한다.
    - 좋은 예) 1. 사용자가 이메일과 이름을 입력한다. 2. 시스템은 사용자 정보를 보여준다
- 시기는 선택적으로 작성
    - 예) 사용자가 000하면 시스템은 000한다. 2단계와 4단계 사이 사용자는 000한다.
- 상호작용을 이해하기 쉬운 표현으로 작성
    - 사용자는 A시스템에게 B시스템으로부터 000 데이터를 가져오게 한다
    - 시스템은 000이 처리되는 동안 000과 XXX를 반복처리 한다

## Sequence Diagram
- 실행시점의 객체간의 상호작용을 시간 흐름에 따라 순차적인 메시지 구조로 모델링
- 객체 사이의 기능, 순서, 시간에 따른 처리를 가능한 명확하게 표현
- 보통 단일 유스케이스의 시나리오를 분석할 때 사용 -> Usecase Realization
- 복잡한 행위는 Activity Diagram 사용
- Use Case Diagram이 정의된 후 부터 프로그램 코딩 전까지 수행
- 분석 단계에서는 비즈니스 관점, 설계 단계에서는 구현 관점

### Sequence Diagram 작성 지침
- 교류를 주도하는 객체를 왼쪽에 배치(메시지 흐름은 액터로 부터 시작)
- 메시지들을 시간의 흐름에 따라 위에서 아래로 배치
- 객체 모델링이 원칙이나 다양한 정적 대상(클래스, 시스템 등)도 포함 가능.
- 유스케이스별로 하나씩 작성하는 것이 원칙
- 동일한 상호 작용이 유사하게 중복 작성되는 것은 피함.(UI별 작성으로 중복 회피)
- 이해를 위한 적당한 comment 사용
- 번호로 순차 표시를 할수도 있음
- 일반적으로 분산 제어가 적합하나 아키텍처와 서비스 구성에 따라 다름.
- 도메인 / 클래스 다이어그램에 표시된 이름과 매칭되는 것이 좋음

### Sequence Diagram – 구성 요소
- Object, Lifeline: 객체의 생존 기간, 실선 뿐만 아니라 객 체까지를 포함
- Message: 객체와 객체의 상호작용을 표현, 화살표 모양, 선의 구성에 따라 따라 동기, 비동기, 셀프, 답신 메시지 등으로 구분
- Activation: 객체가 수행하는 오퍼레이션이 실행중을 의 미. Life line 위에 세로로 긴 직사각 라인으로 표현
- Guard: 단일 메시지에 조건 명시, [price > 10000]배송비 무료 처리, 단독 혹은 fragment 에서도 사용
- Sequence fragment: 제어문 표현을 위한 블록
- alt(alternative), opt(option), loop, par(parallel)

## Class Diagram
- 오브젝트 모델링 프로세스의 근간
- 시스템의 정적 구조를 모델링
- 시스템에서 사용되는 객체 타입을 정의하고, 그들 간에 존재하는 정적인 관계를 다양한 방식으로 표현
- Class, Interface, Collaboration, Relation을 이용하여 시스템의 정적인 관점들을 가시화하고 구축을 위한 자세한 내용을 명세화하는 다이어그램.
- 실제 구현 단계에 가장 근접 -> Forward Engineering
- Logical Database Design 수행 가능

### Class Diagram 작성 지침
- 개념단계
    - 클래스만 도출
    - 관계를 단순화 해서 표현 -> 도메인 모델로 표현 하기도 함.
- 명세와 구현 단계
    - 개발 직전 단계에서 설계 및 구현 이후 설명의 목적으로 사용
    - 구체적으로 작성되고 이를 기반으로 코드를 작성
    - 클래스 다이어그램과 코드를 직접 연계하는 것은 비 현실적

### Class Diagram – 구성 요소
- Class, Interface: OOP의 클래스 및 인터페이스 개념, 속성, 메서드
- assosication: 클래스간의 연결된 관계를 의미, has a 관계
- aggregation: 집합연관, Associate 관계이면서 전체와 부분인 part of 관계, 생명 주기를 같이 하지 않는다.
- composition: 복합연관, 전체와 부분의 관계로 contains a 관계, 전체가 소멸 시 부분도 소멸.
- dependency: 의존관계, 개념적으로 연관되어 있으나 일시적인 관계, 클래스가 변경되면 사용하는 곳도 변경되어야 하는 강결합.
- generalization: 일반화된 개념적 사물과 구체화된 특수 사물의 관계, 상속, is a 관계.
- interface realization: 인터페이스 구현.

## State Machine Diagram
- 이벤트 발생이나 시간의 흐름에 따라 바뀌는 객체의 상태를 나타냄
- 특정 객체 내부의 자세한 동작을 기술하거나 시스템 전체의 자세한 동작을 기술
- 비즈니스 모델링 과정에서 유스케이스 시나리오를 모델링하는데 사용
- 분석 및 디자인 과정에서는 오브젝트 컨텍스트 외부의 이벤트에 반응하는 이벤트 구동 오브젝트를 모델링 하거나 동일한 상태 머신과 동작의 여러 다른 측면을 표현
- 사앹 다이어그램에서 분석 대상인 객체의 상태는 속성 값으로 정의되고, 이벤트는 대부분 객체의 동작으로 정의
- 클래스 다이어그램에서 정의된 클래스의 속성과 동작의 적합성을 검증할 수 있음

### State Machine Diagram - 구성 요소
- 상태 State: 객체가 존재할 수 있는 조건으로 모서리가 둥근 사각형으로 표시
- 가드 Guard: 전이에 대한 제약 조건 표시
- 전이 Transition: 객체가 다른 상태로 변화되는 것으로 화살표로 표시

## Activity Diagram
- 시스템에서 발생하는 액션이나 동작을 단계적으로 표현
- 주로 비즈니스 프로세스 모델링에 많이 사용된다
- 화면 흐름을 표현하는 경우에도 유용하다
- 플로우 차트와 유사한 구조이나 병렬처리 표현이 가능
- 객체의 행위를 나타내며 상태 다이어그램을 확장
- 분석 단계에서는 유스케이스의 구체적인 흐름(시나리오)을 표현
- 설계 단계에서는 클래스 내부 동작에 대한 알고리즘이나 구체적인 로직의 표현이 가능
- 하나의 액션은 서브 액티비티로 분해될 수 있다

### Activity Diagram – 구성 요소
- 시작점initial state: 활동의 시작, 속이 채워진 원.
- 종료점final state: 활동의 종료, 이중 원.
- 활동action: 특정 시점의 객체 행위, 모서리가 둥근 사각형.
- 전이transition: 하나의 활동이 끝나고 다음 활동으로 넘어가는것. 화살표로 표시.
- 구획partition: 상태의 흐름을 구분하기 위한 영역으로 사용자와 시스템간의 인터랙션의 연관성을 표현할 수 있다.
- 포크fork: 하나의 입력 전이와 여러 출력전이를 동시 처리
- 조인join: 여러 입력 전이와 하나의 출력전이. 포크의 종료
- 결정decision: 하나의 입력과 조건에 의한 출력 전이 분기.
- 병합merge: 여러 입력과 하나의 출력 전이로 병합.

## Component Diagram
- 컴포넌트간의 관계를 구조적으로 표현
- 일반적으로 소프트웨어 컴포넌트를 말하며 인터페이스를 포함
- 컴포넌트는 제공되는 인터페이스를 통해 연결
- 어떤 실행 모듈이 존재하고 이들이 서로 어떤 연관성이 있는지에 대한 종속성을 표현
- 사용자에게 논리적 혹은 물리적인 시스템 구조를 전달하는데 효과적

### Component Diagram - 구성 요소
- 컴포넌트: 논리적 요소(예: 클래스)들을 물리적으로 패키지화한 요소. 배치 다이어그램의 노드에 해당. 탭이 달린 직사각형으로 표현
- 인터페이스: 컴포넌트가 실현하고자 하는 여러 기능의 집합
- 관계: 의존관계와 실체화 관계

# OOAD(Object Oriented Analysis and Design)
## OOAD 개요
### 객체지향 방법론
- 프로그램을 객체와 객체간의 인터페이스 형태로 구성하기 위해 문제 영역에서 객체, 클래스 및 이들 간의 관계를 식별해 설계 모델로 변환하는 방법론이다.
- 복잡한 메커니즘의 현실 세계를 인간이 이해하는 방식으로 시스템에 적용하는 개념으로 이를 위해 객체, 클래스, 메시지를 기본 모형으로 제시
- 보다 중요한 것은 단순한 현실 세계의 모방이 아닌 추상화를 통한 객체의 정의 그리고 이들 객체 간의 역할, 책임, 협력을 서술해 나가는 것

### Analysis
- 분석은 솔루션 보다는 문제와 요구사항에 대한 조사를 강조.
- 어떻게 사용될 것인가? , 기능은 무엇인가?
- requirement analysis, object oriented analysis
- 분석은 What에 관한 것이다. 즉 어떤 것을 만들어야 하는가?에 대한 질문.
- Do the Right Thing : 어떤 것을 만드는 게 맞는 것인가? -> right thing: 고객이 원하는 것.

### Design
- 설계는 구현 보다는 요구사항을 실현시키는 개념적 솔루션(소프트웨어 및 하드웨어)을 강조.
- 데이터베이스 스키마와 소프트웨어 오브젝트에 대한 설명
- 디자인 아이디어는 저수준 혹은 명확한 세부 사항에 대해서는 종종 생략
- 디자인은 구현될 수 있고 구현은 완전한 디자인의 실현.
- object oriented design, database design
- 디자인은 How에 관한 것. 분석 이후에 어떻게 설계를 해야하는가?에 대한 질문
- Do the thing Right : 옳은 방식으로 설계 방향을 가져야 한다. -> right: 올바른 프로세스

### Object Oriented Analysis
- 분석은 도메인에 대한 이해 활동
- 도메인에서 객체나 개념들을 찾아서 기술하는데 중점.
- 현실 세계를 단순화 하고 모델링

### Object Oriented Design
- 설계는 솔루션 결정 활동
- 소프트웨어 객체를 정의.
- 제공해야 할 기능을 찾고 세분화 하고 그 기능을 알맞은 객체에 할당 하는 과정
- 객체들이 요구사항을 만족시키기 위해 어떻게 협동하는지에 중점.
- 협동은 메소드 호출을 통해 실현됨.

### 객체지향 분석 설계 도구
- 객체지향 분석: 유스케이스 다이어그램, 액티비티 다이어그램, 페키지 다이어그램, Analysis Class Diagram, System Sequence Diagram, State Machine Diagram, Prototype(User Interface)
- 객체지향 설계: 컴포넌트 다이어그램, Deployment Diagram, Package Diagram, 디자인 클래스 다이어그램, 디테일 시퀀스 다이어그램, 커뮤니케이션 다이어그램, 액티비티 다이어그램, State Machine Diagram, CRC, Design Patterns

## 방법론과 프로세스
### 방법론
정의된 작업들을 어떤 순서 및 방법으로 하는가를 다루는 것
- 프로세스의 구체적인 구현 이름
- 어떻게 하는가에 중점
- 결과물을 어떻게 표현하는지 표시
- 패러다임에 종속적
- 각 단계의 절차, 기술, 가이드라인을 제시
- 예) 구조적, 객체지향, 컴포넌트, 애자일 방법론 등

### 폭포수 형태의 프로세스
- 활동을 기반으로 프로젝트를 분할
    - 예) 요구사항 분석, 설계, 코딩, 테스트
### 반복적인 프로세스
- 기능의 하위집합으로 프로젝트를 분할
    - 예) UP의 Phase와 Work Flow, Activity
### Agile 프로세스
- XP(eXtream Programming), Scrum, FDD(Feature Driven Development), Crystal, DSDM(Synamic, Development Method)
    - 사람 중심의 프로세스 -> 프로세스의 성공여부는 팀원의 능력과 팀워크에 좌우
    - 프로세스의 종류나 도구의 종류는 부차적인 문제
    - 매우 짧게 설정된 타임 박스 반복 -> 기간을 늘리지 않고 기능 축소, 규칙적인 개발흐름 유지 가능

## Unified Process란
- 반복적, 점진적 소프트웨어 개발 프로세스 프레임워크이다. 가장 잘 알려지고 많이 문서화된 통합 프로세스가 RUP(Rational Unified Process)이며, 이외에 OpenUP, Agile UP, BUP 등이 있다.

## Unified Process 개요
- RUP: Rational Unified Process
RUP는 UML 탄생에 공헌한 Ivar Jacobson, Grady Booch, and James Rumbaugh의 방법들이 통합되어 1998년 발표된 Rational Software(1981년 설립, 2003년 IBM에 인수됨)라는 회사의 process product 이다.
기본적으로 Unified Process 철학에 기반하고 있으며 그 자체로 제 품화 되어 있어 다음과 같은 요소를 포함.
- 개발을 돕는 맞춤형 프로세스 프레임워크
- 프로세스를 자동으로 적용하는 도구
- 프로세스와 도구를 사용하도록 촉진하는 서비스

### RUP 구조 및 모델
프로젝트를 시간의 흐름에 따라 4개의 Phase와 6(+3) Discipline의 2차원 구조로 정의.
- Phase: 동적, 생명주기 관점, 단계별 마일스톤 제시
- Discipline: 정적, 엔지니어링 관점, Workflow, Activity
- 6개 핵심 Workflow: 비즈니스 모델링, 요구사항, 분석/설계, 구현, 시험, 배치
- 3개 지원 Workflow: 프로젝트 관리, 구성(형상)/변경관리, 환경
- 구성요소: 작업자, 액티비티, 산출물, 워크플로우

### Phase
Phase는 시간의 흐름에 따라 구성되며 핵심 워크플로우 혹은 액티비티는 목적에 따라 정도의 차이를 두고 진행된다.
- Inception: 문제에 대한 이해. 프로젝트 초기 평가
- Elaboration: 유스케이스 정련, 솔루션 아키텍처 검증
- Construction: 점진적인 솔루션 구축과 검증
- Transition: 구현된 솔루션 검증과 운영환경으로의 이

## Domain Model and Domain Driven Design
### Domain Model
#### Domain
- 도메인은 문제를 해결해야 하는 특정 영역으로써 -> 사용자가 프로그램을 사용하는 대상 분야
- 한 도메인은 다시 여러개의 하위 도메인으로 나뉠 수 있다
    - 예) 온라인 쇼핑몰의 하위 도메인: 상품, 회원, 주문, 정산, 배송 등
- 모든 도메인에 대해 하위 도메인이 존재하는 것은 아니며 상황에 따라 다름
    - 예) 대상이 기업인지, 사용자인지
- 특정 도메인을 위한 SW라고 해도 도메인이 제공해야 발할 모든 기능을 구현해야 하는것은 아님
    - 예) 결제나 배송은 외부 업체나 시스템을 이용

#### Domain Model
- 소프트웨어 개발과 관련된 이해관계자들이 도메인에 대해 생각하는 관점.
- 특정 도메인, 즉 문제 도메인problem domain에서 실세계에 존재(혹은 존재하지 않지만 중요한)하는 객체를 소프트웨어 관점이 아닌 개념적 관점에서 본 투시도
- 사용자가 프로그램을 사용하는 영역에 관한 지식을 선택적으로 단순화 하고 구조화한 형태
- 도메인 객체는 비즈니스 로직등 대상 도메인 공간에 존재하는 사물을 표현하는 소프트웨어 객체
- 주로 클래스 다이어그램으로 표현 하지만 도메인 이해가 목적이므로 상태 다이어그램등 다양하게 활용

#### Domain Modeling Guideline
- 지도제작자(map maker)처럼 생각하라!
    - 지도는 길을 찾는 데 필요한 구체적 기능이 아니라 길을 찾을 수 있는 구조를 제공
    - 길을 찾는데 필요한 모든 정보가 지도에 포함
    - 범위에서 벗어나거나 관계 없는 특징은 배제
    - 존재하지 않는 것들은 추가하지 마라
- 실제 세계를 모델하라!
    - 도메인 전문가들이 사용하는 핵심 단어, 개념들을 사용
- 속성(Attribute)과 클래스(Class)에 관한 잘못된 오해
    - 어떤 X라는 개념적 클래스를 텍스트나 숫자로 생각하지 않는다면 그것은 개념적 클래스에 해당
    - 속성은 숫자, 텍스트로 나타낼 수 있어야 함
    - 예시: 상점과 매출은 분리되어야 하는 개념적 클래스들인가? 아니면 상점 아래에 매출이라는 속성이 있어야 하는가?

### DDD: Domain Driven Design
- Eric Evans가 2003년 처음 소개
- 데이터에 종속적인 어플리케이션, 모델링과 개발과의 불일치 문제를 해결하기 위해 탄생
- 소프트웨어의 복잡성을 낮추기 위한 기법 중 하나
- 공통의 언어(Ubiquitous)를 사용해 도메인과 구현을 충분히 만족하는 모델을 만듬
- 전략적 설계와 전술적 설계
- 모델 주도  설계 패턴을 사용
- Presentation, Application, Domain, Infrastructure의 4가지 영역을 가짐
- Aggregate, Entity, Value, Repository 등으로 구성

# 소프트웨어 아키텍처 개론
## 소프트웨어 아키텍처
- 소프트웨어를 구성하는 구성 요소와 이들간의 관계를 정의
- 프로세스, 데이터, 관계 구성 요소들로 구분
- 소프트웨어 아키텍처를 통해 소프트웨어 구성 관계와 흐름을 이해
- 소프트웨어에서 요구되는 품질속성의 목표 달성을 위한 설계 원칙을 제공
- 소프트웨어의 뼈대를 구성하며 청사진의 역할을 수행
- 의사소통의 도구로 활용

IEEE 1471 - Recommended Practice for Architectural Description of Software- Intensive Systems
- 소프트웨어 아키텍처의 표현과 관련된 구성요소와 이들간의 관계를 규정한 표준
- Best practice 기반 국제 표준
    - Mission: 시스템이 수행되어야 하는 목적
    - Environment: 시스템이 어떤 환경(시스템 개발, 동작, 연동, 정치적 측면등)에서 구동 되는가
    - Model: 데이터, 기능, 기술, 인력 및 이들 사이의 관계와 상호작용에 대한 비즈 니스적 관점을 도식화
    - Stakenolder: 시스템과 관련된 모든 이해 관계자(조직, 기획자, 설계자, 개발자, 운영 자, 사용자 등)
    - Concern: 이해관계자의 관심 사항(보안, 신뢰성, 성능) 등
    - View: 시스템을 구성하는 아키텍처를 바라보는 여러 관점
    - Viewpoint: 아키텍처를 바라보는 관점(View)를 명세화 하는 언어와 방법을 정의
    - Architecture: 아키텍처를 구성하는 구성요소와 구성요소들의 관계
    - Rationale: 아키텍처의 근거

## IEEE 1471 - 아키텍처 설계 순서
1. 아키텍처 관련 문서의 파악
2. 이해관계자의 역할 및 아키텍처 관심 사항 파악
3. 뷰포인트의 선택 및 명세
4. 뷰의 명세
5. 뷰들 간에 존재하는 불일치성 파악 및 기록
6. 선택되어 설계된 아키텍처에 대한 논리적 근거(Rationale) 작성

## 아키텍처 요소
- Structure
    - 시스템이 구현된 아키텍처 스타일의 종류
    - Microservices, Layered, Microkernel
    - 구조가 아키텍처는 아님
- Architecture Characteristics
    - 시스템의 기능과 직교하는 시스템의 성공 기준 (success criteria)을 결정
    - bilities로 끝나는 것들
    - QA(Quality Attribute)에 해당
- Architecture Decisions
    - 시스템 구축에 필요한 규칙들을 정한 것
    - 시스템의 제약조건(constraint)를 형성
    - 반드시 지켜야할 규칙
- Design Principles
    - 가이드라인
    - 성능향상을 위해 비동기 메시징을 사용해야 한다는 등
    - 선택과 우선 권장에 대한 가이드라인

## 소프트웨어 아키텍트란
- 고수준의 설계적 결정을 수행하고 소프트웨어 코딩 표준, 도구, 플랫폼을 포함한 기술 표준을 설계하고 개발의 성공을 주도해 나가는 사람
- 프로젝트 매니저(PM)가 아님
- 소프트웨어가 언제 어떻게 전달되는지 결정하는 사람
- 소프트웨어가 비즈니스 목표에 부합하도록 이끄는 사람
- 다양한 기술, 프레임워크, 플랫폼, 환경에 노출 -> 익숙한 영역(compot zone)을 늘려가야 함
- 일정 수준 이상의 비즈니스 도메인 전문가 여야 함
- 리더쉽을 포함한 대인 관계 기술을 보유
- 비즈니스와 기술 문제를 해결하기 위해 아키텍처와 설계의 차이점을 알고 이 둘을 긴밀하게 통합한 솔루션을 모색하는 사람

## 아키텍처와 설계
- 아키텍처와 설계의 차이는 다소 모호함.
- 최신의 개발은 매 iteration 마다 끊임없이 변화하고 발전하기 때문에 아키텍트와 개발자의 협업이 중요
- 사실상 아키텍처와 설계의 경계를 구분하기는 어려움
- 아키텍처와 설계 모두 개발 라이프사이클의 일부로 항상 서로 동기화 되어야 성공 가능

## Architectureal Structures and Views
## View는 Software Architecture를 다양한 측면에서 바라 보는 것
- Three View: Module, Component and Connector, Allocation View. (CMU SEI)
    - View, Viewtype, Structure 등으로도 표현.
- 4+1 View: Rational Unified Process
- Siemens 4 View: Conceptual, Module, Code View

## 3-View
- Mudule View
    - 모듈 구조는 디자인 시점에 만들어지고 코드를 작성할 때 상호 작용을 하게 됨
    - 소프트웨어가 동작하지 않아도 됨 -> static 구조 관점
- C&C(Component & Connector) View
    - 런타임 시점에 의미 있음
    - 소프트웨어가 실제 동작할 때 의미 있음
- Allocation View
    - 모듈과 C&C가 어떤 관계에 있는지 물리적인 요소로 표현
> Module and Component: 모듈은 설계 시점에 의미 있는 요소이며 컴포넌트는 런타임 시점에 의미 있는 요소

## Laws of Software Architecture
### 소프트웨어 아키텍처 제1법칙
- Everything in software architecture is a trade-off.
### 소프트웨어 아키텍처 제1정리
- If an architect thinks they have discovered something that isn’t a trade-off, more likely they just haven’t identified the trade-off yet.
### 소프트웨어 아키텍처 제2법칙
-  Why is more important than how.

## 아키텍처의 모든 것은 다 트레이드오프이다.
- 모든 솔루션의 트레이드오프를 분석해 최적의 솔루션을 결정
- 아키텍처에 영향을 미치는 요인
    - Development Environment
    - Business Drivers
    - Company Culture
    - Budgets
    - Timeframe
    - Developer skill set

## Modularity
- 모듈(Module): 만들어진 산출물의 구현 단위
    - 메서드, 클래스, 패키지, 모듈
- 컴포넌트(Component): 실행중인 소프트웨어의 활동 단위
    - 하나의 클래스 혹은 여러 클래스/패키지와 인터페이스의 집합
## 모듈
복잡한 구조를 만드는 데 쓰이는 각각의 표준화한 부품이나 독립적인 단위
- 프로그램 언어에 따라 다를 수 있으나 자바의 메서드 -> 클래스 -> 패키지 -> 모듈 구조 참조
- 모듈 설계 원칙
    - 응집도(Cohesion)는 높고 결합도(Coupling)는 낮게 유지(From GRASP)
    - 모듈 개수는 적당해야 함. 너무 많을 경우 통합 비용이, 너무 적을 경우 모듈당 개발 비용이 많이 들게
## 응집
한 모듈을 구성하는 구성 요소들의 집합
- 기능적 응집(functional cohesion)
    - 모듈내 모든 요소들이 하나의 기능을 수행하기 위해 구성된 형태
- 순차적 응집(sequencial cohesion)
    - 한 요소의 출력이 다른 요소의 입력으로 차례로 사용되는 형태(순서 중요)
- 통신(교환)적 응집(communicational cohesion)
    - 동일한 입력과 출력을 사용해 다른 기능을 수행하는 활동들이 모여 있는 형태(순서 상관X)
- 절차적 응집(procedural cohesion)
    - 여러 기능 요소가 순차적으로 진행
- 일시적 응집(temporal cohesion)
    - 순서에 상관없이 특정 시점에 반드시 수행되어야 하는것들을 모아둔 형태
- 논리적 응집(logical cohesion)
    - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 형태
- 우연적 응집(coincidental cohesion)
    - 모듈 내부의 각 구성 요소들이 아무런 관련 없이 구성된 형태

## LCOM(Lack of Cohesion in Methods)
- Chidamber and Kemerer 가 개발한 모듈의 구조적 응집도 평가 방법
- 공유 필드를 통해 공유되지 않는 메서드의 총 개수
- 아키텍처 스타일 전환을 위한 코드베이스 분석에 유용
- LCOM을 통해 얻을수 있는 것은 구조적 응집 결여도일뿐 왜 그렇게 되었는지에 대한 논리적 판단을 제공하는 것은 아님

### 커플링
모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계
- 자료 결합(data coupling)
    - 모듈간에 단순히 파라미터 등을 통해 데이터를 주고 받는 형태
- 스탬프 결합(stamp coupling)
    - 두 모듈이 동일한 자료 참조, 모듈간 인터페이스로 배열, 오브젝트 등이 전달되는 형태
- 제어 결합(control coupling)
    - 어떤 모듈이 다른 모듈 내부의 논리적 흐름을 제어하는 요소를 전달하는 경우
- 외부 결합(external coupling)
    - 모듈이 외부에 있는 다른 모듈 또는 데이터를 참조할 때의 결합 상태
- 공통 결합(common coupling)
    - 여러 모듈이 하나의 데이터 영역을 참조하여 사용하는 형태
- 내용 결합(content coupling)
    - 한 모듈이 다른 모듈의 내부 기능과 데이터를 직접 참조하는 경우

### SOLID
- SRP(Single responsibility Principle)
    - 소프트웨어의 설계 부품(클래스, 함수 등)은 하나의 책임만 가져야 한다
    - 클래스 숫자는 늘어나지만 프로그램 복잡도는 낮아질 수 있다
- OCP(Open Closed Principle)
    - 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야 한다
    - 변경이 필요한 경우 기존 코드를 변경하지 않고 상속과 확장을 통해 대응
    - 변경 비용은 줄이고 확장은 최대화
- LSP(Liskov Substitution Principle)
    - 부모 클래스와 자식 클래스 사이의 행위에는 일관성이 있어야 한다는 원칙
    - 상위 타입의 객체를 하위 타입의 객체로 치환해도 코드가 문제 없어야 한다는 원칙
    - 상속은 다형성을 통한 확장성 획득이 목표
    - 다형성과 확장성을 극대화하려면 인터페이스 사용
- ISP(Interface Segregation Principle)
    - 사용하지 않는 메소드에 대한 의존 관계 배제
    - 사용자에게 필요한 메소드만 인터페이스로 제공
    - 하나의 일반적인 인터페이스 보다는 여러개의 구체적인 인터페이스가 낫다
- DIP(Dependency Inversion Principle)
    - 추상화에 의존해야지, 구체화에 의존하면 안된다
    - 의존 관계를 맺을 때, 변화하기 쉬운 것 보단 변화하기 어려운 것에 의존해야 한다는 원칙
    - 변동성이 큰 구체 클래스를 참조하지 마라
    - 변동성이 큰 구체 클래스로부터 파생하지 말라

## GRASP(General Responsibility Assignment Software Patterns)
일반적인 책임 할당 소프트웨어 패턴 내지는 기본 객체 설계 학습을 위한 방법론
1. Information expert
2. Creator
3. High cohesion
4. Low coupling
5. Controller
6. Polymomrphism
7. Pure fabrication
8. Indirection
9. Protected variations

### GRASP 세부 내용
1. Information Expert
- 책임을 수행할 수 있는 데이터를 가지고 있는 객체에 책임을 부여하는 패턴
- 객체지향에서 객체는 데이터와 처리 로직이 함께 묶여 있음(캡슐화)
- 정보 은닉을 통해 자신의 데이터를 감추고 오직 Method로만 데이터를 처리하고, 외부에는 그 기능만을 제공
2. Creator
- 생성되는 객체의 컨텍스트를 알고 있는 다른 객체가 있다면, 컨텍스트를 알고 있는 객체에 객체 생성 책임을 부여
- 예) Factory 패턴
3. Polymorphism
- 객체의 종류에 따라 동작 방식이 변화된다면 Polymorphism 패턴의 사용을 고려
- 객체의 종류를 체크하는 조건문 대신 다형성을 활용한 구조를 사용
- 예) Strategy Pattern
4. Pure Fabrication
- 도메인에 관련된 문제를 대표하는 기능이 아니라면 기능적인 책임을 별도로 한 곳으로 관리하는 객체를 만들자
- 예) 로깅, 인증, 변환 등의 기능
5. Indirection
- 두 객체 사이의 직접적인 Coupling을 피하고 싶으면, 그 사이에 다른 매개체를 통해 전달하는 것
6. Protect Variation
- 변화에 보호, 변경될 여지가 있는 곳에 인터페이스를 사용

## Software Architecture Design Process
### 소프트웨어 아키텍처 영향 관계
Business Goals <-> Quality Attributes <-> Architecture

### 일반적인 아키텍처 디자인 프로세스
| Process      | Activity | Description |
| ----------- | ----------- | ----------- |
| 요구사항 분석      | 소프트웨어 요구사항       | 요구사항 식별, 분류, 분석, 명세, 기능/비기능 요구사항 분류 및 명세       |
|             | 제약사항      | 기능/비기능 및 기타 제약사항 도출      |
| 아키텍처 분석   | 품질속성 식별        | ISO 9126 -> 25010 품질 매트릭등에 기반         |
|             | 우선순위 결정        | Utility Tree 작성, 품질 시나리오 작성        |
|             | 전술개발        | 품질속성별 접근 방법 개발        |
| 아키텍처 설계   | 아키텍처 뷰 정의        | 관점별 뷰 정의 및 개발, UML 4+1, Siemense 4, CMU SEI 3-View 등        |
|             | 아키텍처 스타일 선택        | 스타일 검토        |
|             | 후보 아키텍처 도출        | 아키텍처 뷰 별 후보 아키텍처 도출        |
| 아키텍처 평가   | 아키텍처 적합성 평가        | 아키텍처 적용에 따른 품질속성별 트레이드 오프 분석        |

### 아키텍처 디자인 방법
- ADD(Attributed Driven Design)
    - ADD is an architecture design method "driven" by quality attribute concerns

## Architectural Driver
### 아키텍처 설계에 직접적으로 영향을 미치는 요건
- 아키텍처를 디자인 하기 위해 아키텍트가 파악해야 할 핵심 요구 사항(ASR)
- 시스템의 Fundamental에 영향을 미침
- 시스템을 위한 모든 요구 사항을 의미하지는 않음(AD는 전체 Requirement subset)
- Architectural Driver는 Architectural Decision에 영향을 미치기 때문에 조기 파악이 중요

### 아키텍처 대응
1. Functional Requirement -> 설계 전반에 걸쳐 적절한 책임(Responsibility)을 순차적으로 부여함으로써 만족. 즉 아키텍처 요소에 책임을 할당하는 것은 아키텍처 설계의 기본적인 결정
2. Quality Attribute -> 아키텍처에 설계된 다양한 구조와 해당 구조를 채우는 요소의 동작 및 상호 작용에 의해 충족
3. Constraint -> Design Decision을 수락하고 영향을 받는 다른 Design Decision과 조화를 이루면 충족

## Quality Attribute
ISO/IEC 25010 "Software Product Quality"
- 소프트웨어의 품질 특성을 정의하고 품질 평가의 Metrics를 정의한 국제 표준
- 8개의 주 특성과 세부 특성들로 구성
- Big Q : 고객의 만족, Small Q : 결합 없는 소프트웨어 요구명세에 부합되는 소프트웨어
- 기능적 요구사항과 비기능적 요구사항 모두 품질 요소가 될 수 있음
- 필요성
    - 사용자, 평가자, 개발자/테스터 모두에게 소프트웨어 제품의 품질을 평가하기 위한 지침
    - 평가대상 소프트웨어의 품질을 직접 측정하기 위해 필요한 평가 Metrics
    - 소프트웨어의 품질을 객관적이고 계량적으로 평가할 수 있는 기본적 틀
- 기존의 ISO/IEC 9126에서 ISO/IEC 25010으로 개정
- 주 특성이 기존 6개에서 8개로 증가
    - 기존: 기능성, 신뢰성, 사용성, 유지보수성, 이식성, 효율성
    - 변경: 기능 적합성, 실행 효율성, 호환성, 사용성, 신뢰성, 보안성, 유지보수성, 이식성
- 부특성 일부 증가
    - 기존 27개 -> 31개 증가
    - 일부 항목 삭제
    - 각 주 특성의 준수성(Compliance) 항목은 전체 삭제

### Quality Attribute - Architecture characteristic
아키텍처 특성: 아키텍처 설계시 고려되어야 하는 핵심 요소
- ASR(Architecturally Significant Requirements)로부터 도출
- 소프트웨어 시스템의 외부에서 볼 수 있는 특성과 시스템에 기대하는 동작
- 시스템이 어떤 작업을 얼마나 잘 수행해야 하는지를 정의
- 일반적으로 비기능 요구사항(Non-Functional Requirement)
- 품질 속성(Quality Attribute)
- ~bilities로 끝나는 것들
- 아키텍처 속성은 다음 세가지 기준을 충족
    - 비도메인 설계 고려사항을 명시 -> 명시적
    - 설계의 구조적 측면에 영향 -> 암묵적
    - 애플리케이션 성공에 절대적으로 중요

### Identifying Architectural characteristics
도메인 관심사에서 아키텍처 특성 도출
- 아키텍트는 도메인 관심사를 올바르게 해석해 정확한 아키텍처 특성을 식별.
    - 예) 확장성, 보안, 성능, 내고장성 중 어느 것이 가장 중요한 관심사인가?
- 도메인의 핵심 목표와 현재 상황을 고려 정확하고 합리적인 아키텍처 결정을 내려야 한다.
    - 도메인 이해관계자와 협력
    - 주요 아키텍처 특성을 가능한 짧게 도출
    - 모든 아키텍처 특성을 지원하는 generic architecture는 흔한 anti-pattern 중 하나.
요구사항에서 아키텍처 특성 도출
- 기본적으로 요구사항 정의서에 명시된 문장에서 도출한 아키텍처 특성
    - 예) 예상 유저수 및 그에 따른 확장 문제
- 아키텍트의 도메인 지식으로 부터 도출되는 특성
- 경험에 의한 특정 도메인 특성 반영

### Software Architecture Strategy
Architecture Design Strategy
- Decomposition: 충분히 시스템 내의 모듈을 분해 해야 한다
- ASR에 의한 설계: 다른 Requirement들에 영향이 없는지 확인해야 한다
- 가설(Hypothesis) 생성과 테스트를 통한 확인

### Software Architecture Tactics
Architecture Design Tactics
- Design decisions that influence the control of a quality attribute response.
- There are tactics categorizations for the quality attributes of:
    - Availability
    - Interoperability • Modifiability
    - Performance
    - Security
    - Testability
    - Usability

## ATAM(Architecture Tradeoff Analysis Method)
- 아키텍처적인 판단이 품질속성에 미치는 상관관계를 분석
- 9개의 단계적 절차로 구성

## ADD(Attribute Driven Design)
- 순차적으로 소프트웨어 아키텍처 수립하기 위한 시스템적인 방법론
- 소프트웨어 시스템의 기능적인 속성과 품질 속성, 그리고 제약사항을 input으로 받아 각각의 속성을 만족시킬 수 있도록 최상위 수준에서 recursive하게 분할하는 과정을 통해 아키텍처를 수립하는 방법

# 디자인 패턴
- 소프트웨어를 설계할 때 특정 상황에서 반복적으로 발생하는 고질적인 문제들에 대한 재사용 가능한 해결책. 디자인 패턴이라는 용어는 건축학에서 출발
- GOF의 4명의 객체지향 전문가에 의해 소프트웨어 디자인 패턴이라는 개념이 처음 소개 됨
- 효율적인 코드를 만들기 위한 방법론
- 소프트웨어 엔지니어링에서 디자인 패턴은 주어진 컨텍스트 내에서 일반적으로 발생하는 문제에 대한 일반적이고 재사용 가능한 솔루션

## DIP, IOC, DI
### DIP(Dependency Inversion Principle)
- SOLID 원칙 중 하나
- 구체클래스가 아닌 추상화(추상 클래스, 인터페이스)에 의존
- 다형성을 이용해 변화에 대응
### IOC(Inversion of Control)
- 코드의 흐름을 제어하는 주체가 바뀌는 것
- 주로 프레임워크 구조를 사용할 때 적용되는 방식
### DI(Dependency Injection)
- 필요로 하는 객체를 직접 생성하는 것이 아닌 외부로부터 주입 받는 기법을 의미

## GoF 디자인 패턴
- 객체의 생성, 구조, 행위와 관련된 영역의 23개 패턴을 정의
- Context, Problem, Solution의 구조로 설명됨
    - Context: 문제가 발생하는 여러 상황, 즉 패턴이 적용될 수 있는 상황
    - Ploblem: 패턴이 적용되어 해결될 필요가 있는 디자인 이슈들. 제약사항과 영향력도 고려
    - Solution: 문제를 해결하기 위한 설계의 구성요소와 객체들의 관계, 책임, 협력 등을 기술. 구체적인 구현방법이나 언어에 의존하지 않는 일종의 템플릿
### 생성(Creational) 패턴
- 추상 팩토리(Abstract Factory)
- 빌더(Builder)
- 팩토리 메서드(Factory Method)
- 프로토타입(Prototype)
- 싱글턴(Singleton)
### 구조(Structural) 패턴
- 어댑터(Adapter)
- 브리티(Bridge)
- 컴포짓(Composite)
- 데코레이터(Decorator)
- 파사드(Facade)
- 플라이웨이트(Flyweight)
- 프록시(Proxy)
### 행위(Behavioral) 패턴
- 책임 연쇄(Chain of Responsibility)
- 커맨드(Command)
- 인터프리터(Interpreter)
- 이터레이터(Iterator)
- 미디에이터(Mediator)
- 메멘토(Memento)
- 옵저버(Opserver)
- 스테이트(state)
- 전략(Strategy)
- 템플릿 메서드(Template Method)
- 비지터(visitor)

### Composition과 Delegation
#### Composition
- 다른 객체를 여러개 붙여 새로운 객체를 구성하는 의미
- 구체 클래스를 상속 받을 경우 발생할 수 있는 문제 해결을 위해 상속 대신 private 필드를 통해 상위(혹은 다른) 클래스에 대한 참조를 만들어 구현하는 접근 방식

#### Delegation
- Composition의 대표적인 구현 방법, Delegation Pattern 이라고도 한다
- Has-a 관계, Proxy, Chain of Reponsibility 등 여러 패턴에서 위임을 활용

## 디자인 패턴 - Cretional 패턴
- 객체의 생성과 참조 과정을 추상화/캡슐화해 특정 객체의 생성 과정을 분리
- 객체가 생성되는 과정의 유연성을 높이고 손쉬운 코드를 유지
### Factory Method
- 객체를 생성하는 인터페이스는 정의하지만, 인스턴스 생성 부분은 서브클래스에 위임 하는 패턴
### Abstract Factory Pattern
- 상세화된 서브 클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 개의 군을 생성하기 위한 인터페이스를 제공
- 개별 제품군 및 객체 생성을 위한 팩토리 클래스에 대한 인터페이스 제공
- Factory Method Pattern의 확장 버전
### Builder
- 여러 구성요소로 이루어진 복합 객체의 생성 과정과 표현과정을 분리시켜 동일한 생성과정을 통해 다양한 객체를 생성하기 위한 패턴
- 생성할 객체가 옵션 속성을 많이 가지는 경우
- 생성자에 인자를 두어 다양한 생성을 지원하는 것에 대한 문제 해결에 적합
### Prototype
- 새로운 객체를 프로토타입(기존 인스턴스)의 복제(Clone)로부터 생성하는 패턴
- 객체를 생성하는데 비용이 많이 들고 빗스한 객체가 있는 경우 유용한 패턴
- 객체 생성시 DB로부터 데이터 로딩, 자료구조 생성 등의 과정을 매번 수행해야 하는 경우
- 자바에서는 Object 클래스의 clone()를 이용해 구현
### Singleton Pattern
- 클래스의 인스턴스가 하나임을 보장하고 접근할 수 있는 전역적인 접근점을 제공하는 패턴
- 자바에서는 static final을 이용한 static binding 으로 구현하는 방법이 일반적
- 구조가 간단하나 미리 생성해 두는 방식이므로 사용하지 않을 경우 자원 낭비가 있을 수 있음

## 디자인 패턴 - Behavioral Patterns
- 클래스나 객체들이 상호작용하는 방법이나 작업, 알고리즘 등을 어떤 객체에 할당하는 것이 좋을지 결정하는 패턴
### Chain of Responsibility Pattern
- 요청을 받는 객체를 연쇄적으로 묶어 요청을 처리하는 객체를 만날 때까지 객체 체인을 따라 요청을 전달하는 패턴
### Command Pattern
- 요청을 객체의 형태로 캡슐화해 재사용하거나 취소할 수 있도록 저장하는 패턴
- ConcreteCommand에서 Receiver의 액션을 통해 동작 수행
- 하나의 커맨드에 서로 다른 리시버의 동작을 수행하도록 할 수 있음
### Interpreter Pattern
- 문법적 규칙을 클래스화 하여 일련의 규칙을 통해 언어/문법 등을 해석하는 패턴
- 반복되는 문제 패턴을 언어 또는 문법으로 정의하고 확장
### Interator Pattern
- 내부를 노출하지 않고 다양한 구조의 집합형 객체 원소를 순차적으로 접근할 수 있는 동일한 인터페이스 제공 패턴
- next(), hasNext() 등 단일한 접근법을 위한 메서드 제공
### Mediator Pattern
- 한 집합에 속해 있는 객체들의 상호작용을 캡슐화해 새로운 객체로 정의하는 패턴
- 특별한 중재자 객체를 통한 간접 통신으로 구성 요소들 간의 결합을 줄임
- 다른 구성요소에 지나치게 의존해 재사용할 수 없는 경우
### Memento Pattern
- 객체가 특정 상태로 다시 되돌아올 수 있도록 내부 상태를 실체화 하는 패턴
- 원하는 시점의 상태 복원이 가능
### State Pattern
- 일련의 규칙에 따라 객체의 상태(state)를 변화시켜 객체가 할 수 있는 행위를 바꾸는 패턴
- 객체의 특정 상태를 클래스로 선언하고 상태에 따른 처리가 가능하게 함
### Template Method Pattern
- 상위 클래스에서는 알고리즘의 골격만 작성하고 구체적인 처리는 서브클래스로 위임하는 패턴
- 추상 클래스의 특징을 사용한 구현 패턴
### Visitor Pattern
- 객체의 원소에 대해 수행할 연산을 분리해서 별도의 클래스로 구성하는 패턴으로 로직과 구조를 분리
- 연산에 대한 부분을 위임하는 패턴
### Observer Pattern
- 객체 상태가 변할 때 관련 객체들이 변화를 통지 받고 자동으로 갱신될 수 있도록 하는 패턴
- 데이터 변경 발생시 상대 객체에 의존하지 않고 데이터 변경을 통보하고자 할 때 유용
### Strategy Pattern
- 알고리즘들을 정의하고 캡슐화해서 상호 교환 가능하게 만드는 패턴
- 변경되는 것이 메서드(행위)일때 조건에 따라 다른 메서드를 호출하거나 내부적인 수정을 통해 구현하는 것이 아닌 클래스로 캡슐화해서 알고리즘의 대체가 가능하게 하는 패턴

## 디자인 패턴 - Structural Pattern
- 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
### Adapter Pattern
- Wrapper 패턴이라고도 함. 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴. 기존 코드의 수정 없이 호환성을 유지하기 위한 패턴
- 처음부터 구조화 되지 않은 설계에서 새로운 규격을 기존 시스템 영향 없이 구현하기 위해서도 사용
### Bridge Pattern
- 구현부에서 추상층을 분리하여 각자 독립적으로 확장할 수 있도록 하는 패턴
- 객체의 확장성 향상을 위해 동작을 처리하는 구현부(기능)와 확장을 위한 추상부를 분리하는 구조
### Composite Pattern
- 객체들의 관계를 트리 구조로 구성하여 복합 객체와 단일 객체를 구분없이 다룰 수 있도록 하는 패턴. 트리구조로 전체-부분 관계를 표현
### Facade Pattern
- 서브시스템에 있는 인터페이스 집합에 통합된 하나의 인터페이스를 제공하는 패턴
    - 인터페이스 집합의 개별 인터페이스는 ISP 원칙을 따라야 함
- 코드의 의존성을 줄이고 느슨한 결합으로 구조를 변경 함으로써 연결성과 종속성을 최소화 하는 것을 목표로 함. 다만 파사드 규모가 커지만 복잡도가 증가될 수 있어 주의 해야 함.
### Proxy Pattern
- 다른 객체로 접근하는 것을 통제하기 위해 객체의 surrogate or placeholder 등을 제공하는 패턴
- 객체를 정교하게 제어해야 하거나 객체 참조가 필요한 경우 사용 가능
- 다른 패턴과 결합된 형태로도 많이 사용됨
- 원격 프록시, 가상 프록시, 보호 프록시 등이 있음
#### Adapter, Facade, Proxy 비교
- Adapter : 서로 다른 구조를 연결하기 위함
- Facade : 내부 시스템을 숨기고 인터페이스를 제공. 기본적으로 다중 서브시스템(인스턴스)에 대한 접근을 중계
- Proxy : 중간에 관리를 위해 추가되는 무언가를 관리. 기본적으로 단일 Target 객체에 대한 컨트롤 추가
### Decorator Pattern
- 동적으로 객체를 결합하기 위해 객체지향 구성을 통해 확장하는 패턴으로 복합객체와 위임을 통해 상속이 아닌 합성을 다통한 확장을 지원하는 패턴
### Flyweight Pattern
- 공통으로 사용하는 클래스를 생성하는 팩토리 클래스를 만들어 인스턴스를 최초 1개만 생성하고 공유해서 재사용할 수 있도록 하는 패턴
- 객체가 많은 메모리를 차지하는 경우 객체의 무분별한 생성을 막고, 가능한 같은 상태의 객체는 다시 생성하지 않고 재활용할 수 있도록 하는 방식

# 아키텍처 설계
## 소프트웨어 아키텍처의 정의
아키텍처는 결과물이 가져야 할 속성(비기능)이 문제없이 시스템에 포함될 수 있도록 만드는 시스템을 위한 계획이며, 이미 구축된 시스템의 설명서이다.
이는 시스템에 요구되어지는 속성 중 어느 하나에도 치우치지 않고 서로 간의 균형과 동등함을 만들어 내는 청사진이다

## CMU's 아키텍처 설계 전략
1. 요구사항의 우선순위 조율
- QAW 품질속성 워크샵
    - 아키텍처 드라이버
    - 품질속성, 시나리오
    - 요구사항 / 품질 속성 중 조율하기
2. 아키텍처 모델링 가볍게 하기
    - 다양한 관점으로 보기(자원, 성능, 코드레벨 등) -> 아키텍처 스타일 도출 -> 주요 컴포넌트 도출
3. 아키텍처 설계, Drill Down 제대로 하기
    - 아키텍처 설계
        - 설계의 원칙들
        - 아키텍처, 성능, 사용성, 확장성 등을 다루는 패턴들
        - 품질 속성 설계 전략들
4. 결과물을 집단 지성으로 평가함
    - ATAM, 아키텍처 평가 모델
        - 아키텍처 분석하기
        - 아키텍처 평가하기

## CMU's 소프트웨어 아키텍처 설계 방법
1. 아키텍처 드라이버
2. 품질속성, 검증가능성, 품질속성시나리오
3. 아키텍처 문제분석
4. 컴포넌트, 커넥터, 인터페이스
5. 아키텍처 스타일
6. 소프트웨어 아키텍처를 보는 관점체계
7. 품질속성 설계전략
8. 설계의 일반원리
9. 아키텍처 설계 절차
10. 아키텍처 패턴
11. 아키텍처의 분석
12. 아키텍처의 평가

## 요구사항 정리
### 아키텍처 드라이버
시스템 아키텍처의 결정에 큰 영향을 미치는 요구사항. 기능요구사항은 간접적으로 품질요구사항을 발생시킴으로써 아키텍처에 영향을 준다

## 품질 속성, 품질 속성 시나리오
### 품질 속성
- 요구사항 중에 미묘하게 아키텍처 결정에 큰 영향을 주는 사항. SW 아키텍처가 만족시켜야 하는 품질 요구사항
- 기능적 품질속성보다 비기능적 품질속성이 아키텍처에 더 큰 영향을 준다
### 품질 속성 시나리오
특정 품질에 대한 요구사항을 명세. 구체적인 품질속성 시나리오를 생성
- 자극 유발원(Source of stimulus) : 자극을 만들어내는 존재로써 사용자, 컴퓨터 시스템, API Call 등
- 자극(Stimulus) : 시스템의 반응의 원인이 되는 조건
- 대상체(Artifact) : 자극을 받는 대상
- 환경(Environment) : 해당 자극이 발생할 때나 다른 조건이 만족되었을 때 시스템의 상태
- 응답(Response) : 자극이 시스템에 도달한 이후에 취해지는 행위이다.
- 응답 측정(Response measure) : 요구사항의 검증이 가능한 형태로, 응답이 발생할 때 측정이 가능한 대응의 결과값

# 아키텍처 패턴
## 클린 아키텍처
- 외부 인터페이스에 독립적으로 구현
- 확장 가능하고 테스트가 가능한 프로그램을 만들기 위한 구조를 제공
- DIP: 인터페이스의 변경이 코드 변화를 일으키지 않도록 함
- DB, UI 등은 바뀌어도 프로그램 자체는 문제없이 돌아가도록 세부 사항으로 다룸
- 바깥쪽 원에 위치할수록 언제든 바뀔 수 있음
- 중앙 원에 위치할수록 변경되지 않음

## 헥사고날 아키텍처
- Port And Adapter ARchitecture라고도 불림
- 포트는 실제 구현 시점에 인터페이스 구조가 됨
- 포트: 내부 비즈니스 영역을 외부에 노출하는 API
- 어댑터: 외부와 포트간 교환을 조정하는 요소
- 포트와 어댑터는 각각 inbound/outbound로 구성

## DDD(Domain Driven Design)
- 데이터 중심의 접근법을 탈피해 도메인 패턴을 중심에 놓고 설계하는 방식
- 분석 모델과 설계, 코드가 다른 구조가 아니라 도메인 모델부터 코드까지 함께 움직이는 구조를 지향
- Aggregate Pattern
    - 데이터 변경 단위로 다루는 연관 객체의 집합
    - root와 boundary로 구성
    - Root only-Aggregate: Aggregate내부의 Entity나 VO를 접근할 때 직접 하지 말고 Aggregate root를 통하라
    - Primary Key 참조 : 다른 Aggregate를 참조할 때 객체 자체를 레퍼런스 하지 말고 객체의 Primary Key로 참조하라
    - One to One : 한 개의 트랜잭션은 한 개의 Aggregate만 Write

## Cache-Aside
- 캐시가 기본 read-Through 및 Write-Through 작업을 제공하지 않는 경우

## Ambassador
- 여러 언어 또는 프레임워크에 대한 클라이언트 연결 기능의 공통 집합(Retry, Circuit Breaking, Monitoring, Security 등)을 구현해야 하는 경우

## CQRS(Command and Query Responsibility Segregation)
- 많은 사용자가 동일한 데이터에 병렬로 액세스 하는 공동작업 도메인에서 병합 충돌 문제를 해결하고 특히 읽기가 쓰기보다 월등히 많은 경우 쓰기 성능과 별도로 읽기 성능을 미세조정이 필요한 경우

## Gatekeeper
- 클라이언트와 애플리케이션 혻은 서비스간 브로커 역할을 수행. 요청을 검사하고 정리, 데이터를 전달하는 전용 호스트 인스턴스를 별도로 두어 애플리케이션 및 서비스를 보호

## Saga Distributed Transactions
- 분산 트랜잭션 시나리오에서 데이터 일관성을 관리하는 방법. 긴밀한 결합 없이 분산 시스템에 데이터 일관성 보장이 필요하거나 시퀀스 작업 중 하나가 실패하는 경우 롤백 혹은 보정이 필요한 경우

## Circuit Breaker
- 실패할 수 있는 작업에서 회로 차단기의 역할을 수행. 분산된 시스템에서 특정 컴포넌트가 느려지거나 장애가 생기면 이를 호출하는 컴포넌트까지 장애가 전파되는 문제를 해결. 장애처리는 별도 처리 필요

## Bulkhead
- 백엔드 서비스 집합을 사용하는데 필요한 리소스를 격리하는 경우, 특히 서비스중 하나가 응답하지 않는 경우에도 애플리케이션이 일정 수준 기능을 제공해야 하는 경우. Pool로 격리 되므로 연속 시랲로부터 애플리케이션 보호 가능